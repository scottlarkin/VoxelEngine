#pragma once
#include "Chunk.hpp"
#include <unordered_map>
#include <atomic>



struct hashFunc
{
    size_t operator()(const glm::ivec3 &key) const
	{
		using std::size_t;
		using std::hash;

        return ((key.x * 5209) ^ (key.y * 1811)) ^ (key.z * 7297);
    }
};

struct equalsFunc
{
	bool operator()(const glm::vec3& lhs,const glm::vec3& rhs )const
	{
		return (lhs.x == rhs.x) && (lhs.y == rhs.y) && (lhs.z == rhs.z);
	}
};	

class ChunkManager
{

public:
	ChunkManager();
	~ChunkManager();

	void LoadChunks();
	void UpdateLists();

	static Chunk* ChunkAt(int x, int y, int z);
	static Chunk* ChunkAt(const glm::vec3& pos);
	
	static const glm::ivec3 Pos2ChunkPos(const glm::vec3& pos);

	void RenderChunks();

	const std::vector<ConcurrentMeshData*>& GetMeshStorage() const;

	void PlayerMoved(){playerMoved_ = 1;condition_.notify_one();}

private:

	//all chunks mapped to their world position
	static std::unordered_map<glm::vec3, Chunk*, hashFunc> chunkMap_;
	
	//list of chunks that should be loaded. Mesh Vertices generated by helper threads.
	static Thread_Safe_Queue<Chunk*> toLoadList_; 
	//list of chunks with generated meshes, ready to be passed to GPU by main thread.
	static Thread_Safe_Queue<Chunk*> loadedList_; 

	std::vector<Chunk*> chunks_;

	std::vector<std::thread> workerThreads_;

	static std::vector<ConcurrentMeshData*> meshStorage_;

	static bool playerMoved_;

	static int threadCount_;

	static bool finished_;


	static std::condition_variable condition_;

	static int maxChunkDist_;

};





